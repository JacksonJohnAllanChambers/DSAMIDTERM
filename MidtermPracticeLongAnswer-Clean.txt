Question 3: Programming and Program Analysis Type Questions 

1. Write a class called Point that has two attributes (xpos and ypos), a constructor that sets xpos 
and ypos, set methods for xpos and ypos, get methods for xpos and ypos, and a toString method 
that returns the values. The class must be written as a generic class, which means that it should 
work for any type of object, say Integer, or Double, or String. Comments not required. 

public class Point<T>{ 
//continue 

2. The following is a method to find the sum of an array of integers. Analyze the code line by line (for 
the line numbers given) and determine the total run time of the algorithm. Assume that the time for 
one basic operation is t. Express it in terms of n, where n is the array length. 

public static int findSum(int[] arr){ 

1.              int sum = 0; 
2.              int index = 0; 
3.              while (index<arr.length){ 
4.                      sum = sum + arr[index]; 
5.                      index++; 
                } 
6.              return sum; 

} 

Question 4:  
4 (A) An algorithm takes 30 milliseconds to process 256 data items. Estimate how long it will 
take to process 1024 data items if the complexity of the algorithm is each of the following:  
a) O(n) 

b) O(root(n))
c) O(n logbase2(n)) 

(Show steps). 
 
4 (B) An algorithm with complexity O(n^2) takes 5 ms to process 50 data items. 

a) Estimate how long it will take to process 5000 data items. (Show steps). 

b) Estimate how much data can be processed in 500 ms. (Show steps). 

Question 5: Derive the Big O complexity of each of the following code segments, separately. 
What is the Big O complexity of all the code segments together (written one below the other)? 

Code Segment 1:  
for (int i = 1; i <= n; i++)  
     sum++;  

Code Segment 2:  

for (int i = 1; i <= n; i++)    

for (int j = 1; j <=n; j++)       

sum++;  

Code Segment 3:  

if (x==10) 

for (int i = 1; i <= n; i++)    

sum++; 

else{ 

for(int i=1;i<=n;i++) 

for(int j=1; j<=n;j++) 

for(int k=1;k<=n;k++) 

sum++; 

} 

Code Segment 4:  

for (int j = 1; j < n; j=2*j)    

sum++; 

Code Segment 5:  

for (int i = 1; i <= n; i++) { 

if (found==true) 

for (int j = 1; j <=n; j++)        

sum++;   

else 

for (int j = 1; j<= n; j++) 
for(int k=1; k<=n;k++) 

sum++; 

} 

Code Segment 6:  

for (int i=1; i<=n; i++)  
        for (int j=1; j<=n; j = 2 * j)  
            for (int k=1; k<=n; k = k * 2)  
                count++; 

Question No. 6 (Linked Lists):  
Suppose the generic Node class has been developed as shown below.  

public class Node<T>{ 

private T data; 
private Node<T> next; 
public Node (T data, Node<T> next){ 

this.data = data; 
this.next = next; 

} 
public T getData(){ 
return data; 

} 
public Node<T> getNext(){ 
return this.next; 

} 
public void setData(T data){ 

this.data = data; 

} 
public void setNext(Node<T> next){ 

this.next = next; 

} 

} 
The LinkedList<T> class has the following structure.  
public class LinkedList<T> 
{ 

private Node<T> front; 
private int count; 

public LinkedList() 
{ 

front = null; 
count=0; 

} 

Add the following methods to the above LinkedList class: 

//scan the list and display the items in the list  
public void enumerate(){ 

//scan the list and display the items with odd indices 1, 3, 5, etc.  
//For example, if the list is 
// front -> Java -> C -> C++ -> Pascal -> Python -> Cobol -> null 
// it should display: C  Pascal Cobol 
//Note: The list is indexed from 0. 

public void displayOdd(){ 

//Add a given item after the first node. If the list is empty, just return. 
//For example, if the list is 
// front -> Java -> C -> C++ -> Pascal -> Python -> null 
// addAfterFront(“Cobol”) should change the list to 
// front -> Java -> Cobol -> C -> C++ -> Pascal -> Python -> null 

public addAfterFront(T item){ 

//Remove the second last item (last but one) in the list. If the list has zero 
// nodes or only one node, just return. 
//For example, if the list is 
// front -> Java -> C -> C++ -> Pascal -> Python -> null 
// removeSecondLast() should change the list to 
// front -> Java -> Cobol -> C -> C++ -> Python -> null 
//As a second example, if the list is 
// front -> Java -> C-> null 
// removeSecondLast() should change the list to 
// front -> C -> null 

public void removeSecondLast(){ 

Question No. 7 (Unordered Lists). Suppose that the Unordered List class has been developed and 
the methods in the class are as shown below: 
Unordered List methods 
Constructors 

List<T>() 

Constructs an empty ordered list 

Methods 
Name 
size 
isEmpty 
clear 
add 

first 
next 
enumerate 
contains 

remove 

removeAll 

What it does 
returns size of the list 
returns true if list is empty 
clears the list 
adds an item to the front of 
the list 
gets the first entry 
gets the next entry 
scans the list and prints it 
searches for a given item and 
returns true or false 
remove an item (first 
occurrence) from the list. 
remove all occurrences of a 
specified item from the list. 

Header 
int size() 
boolean isEmpty() 
void clear() 
void add(T item) 

T first () 
T next() 
void enumerate() 
boolean contains(T 
item) 
void remove(T item) 

void removeAll(T 
item) 

7.1. Using these methods, implement a method that takes in two unordered lists as arguments to 
the method and creates and returns a third list that contains the elements in list1 and in list2. 

For example,  
if  list1 is {C++, C, C#, COBOL, Python, Ada}and  

       list2 is  {C, Java, Python, Ada, Javascript} 

the returned list is {C++, C, C#, COBOL, Python, Ada, Java, Javascript} 
Order does not matter. You may also assume that the items are not repeated within each list. 

public static<T> List<T> union(List<T> list1, List<T> list2) 
{ 

//continue 

7.2. Using these methods, implement a method that takes in two unordered lists as arguments to the 
method and creates and returns a third list contains the elements in list2 but not in list1.For 
example,  
if  list1 is {C++, C, C#, COBOL, Python, Ada}and  
list2 is  {C, Java, Python, Ada, Javascript} 
the returned list is {Java, Javascript} 
Order does not matter. You may also assume that the items are not repeated within each list. 

public static<T> List<T> difference(List<T> list1, List<T> list2) 
{ 
  //continue 
